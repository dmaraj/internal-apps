-- drop objects
drop table TST_COMPANY cascade constraints;
drop table TST_CATEGORY cascade constraints;
drop table TST_EMPLOYEE cascade constraints;
drop procedure TST_TAGS_sync;
drop table TST_TAGS cascade constraints;
drop table TST_TAGS_tsum cascade constraints;
drop table TST_TAGS_sum cascade constraints;
drop table TST_HISTORY cascade constraints;
drop view TST_HISTORY_V;
drop sequence TST_HISTORY_SEQ;
drop sequence TST_ROW_KEY_SEQ;
drop package TST_COMPANY_API;
drop package TST_CATEGORY_API;
drop package TST_EMPLOYEE_API;

-- sequences
create sequence TST_ROW_KEY_SEQ;

-- create tables
create table TST_COMPANY (
    ID                             NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY  
                                   constraint TST_COMPANY_ID_PK primary key,
    ROW_VERSION                    INTEGER not null,
    ROW_KEY                        VARCHAR2(30)
                                   constraint TST_COMPANY_ROW_KEY_UNQ unique not null,
    NAME                           VARCHAR2(255),
    CREATED                        TIMESTAMP WITH LOCAL TIME ZONE not null,
    CREATED_BY                     VARCHAR2(255) not null,
    UPDATED                        TIMESTAMP WITH LOCAL TIME ZONE not null,
    UPDATED_BY                     VARCHAR2(255) not null
)
;

create table TST_CATEGORY (
    ID                             NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY  
                                   constraint TST_CATEGORY_ID_PK primary key,
    ROW_VERSION                    INTEGER not null,
    ROW_KEY                        VARCHAR2(30)
                                   constraint TST_CATEGORY_ROW_KEY_UNQ unique not null,
    NAME                           VARCHAR2(255),
    CREATED                        TIMESTAMP WITH LOCAL TIME ZONE not null,
    CREATED_BY                     VARCHAR2(255) not null,
    UPDATED                        TIMESTAMP WITH LOCAL TIME ZONE not null,
    UPDATED_BY                     VARCHAR2(255) not null
)
;

create table TST_EMPLOYEE (
    ID                             NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY  
                                   constraint TST_EMPLOYEE_ID_PK primary key,
    COMPANY_ID                     NUMBER
                                   constraint TST_EMPLOYEE_COMPANY_ID_FK
                                   references TST_COMPANY on delete cascade,
    CATEGORY_ID                    NUMBER
                                   constraint TST_EMPLOYEE_CATEGORY_ID_FK
                                   references TST_CATEGORY on delete cascade,
    ROW_VERSION                    INTEGER not null,
    ROW_KEY                        VARCHAR2(30)
                                   constraint TST_EMPLOYEE_ROW_KEY_UNQ unique not null,
    NAME                           VARCHAR2(255),
    CREATED                        TIMESTAMP WITH LOCAL TIME ZONE not null,
    CREATED_BY                     VARCHAR2(255) not null,
    UPDATED                        TIMESTAMP WITH LOCAL TIME ZONE not null,
    UPDATED_BY                     VARCHAR2(255) not null
)
;


-- tag framework
create table TST_TAGS (
    id                    number not null primary key,
    tag                   varchar2(255) not null enable,
    content_pk            number,
    content_table         varchar2(128),
    created               timestamp with local time zone not null,
    created_by            varchar2(255) not null,
    updated               timestamp with local time zone,
    updated_by            varchar2(255) )
;

create or replace trigger TST_TAGS_BIU
before insert or update on TST_TAGS
for each row
begin
   if inserting then 
      if :NEW.ID is null then 
        select to_number(sys_guid(),'XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX') x
        into :new.id
        from dual;
      end if;
      :NEW.CREATED := LOCALTIMESTAMP;
      :NEW.CREATED_BY := NVL(SYS_CONTEXT('APEX$SESSION','APP_USER'),user);
   end if; 
   if updating then 
      :NEW.UPDATED := LOCALTIMESTAMP; 
      :NEW.UPDATED_BY := NVL(SYS_CONTEXT('APEX$SESSION','APP_USER'),user);
   end if; 
end; 
/

create table TST_TAGS_TSUM (
    tag                    varchar2(255),
    content_table          varchar2(128),
    tag_count              number,
    constraint TST_TAGS_tspk primary key (tag,content_table) )
;

create table TST_TAGS_SUM (
    tag                    varchar2(255),
    tag_count              number,
    constraint TST_TAGS_spk primary key (tag) )
;

create or replace procedure TST_TAGS_SYNC (
    p_new_tags          in varchar2,
    p_old_tags          in varchar2,
    p_content_table     in varchar2,
    p_content_pk        in number )
as
    type tags is table of varchar2(255) index by varchar2(255);
    type tag_values is table of varchar2(32767) index by binary_integer;
    l_new_tags_a    tags;
    l_old_tags_a    tags;
    l_new_tags      tag_values;
    l_old_tags      tag_values;
    l_merge_tags    tag_values;
    l_dummy_tag     varchar2(255);
    i               integer;
    function string_to_table (
        str    in varchar2,
        sep    in varchar2 default ':')
        return tag_values
    is
        temp         tag_values;
        l_str        varchar2(32767) := str;
        pos          pls_integer;
        i            pls_integer := 1;
        l_sep_length pls_integer := length(sep);
    begin
        if str is null or sep is null then
            return temp;
        end if;
        if substr( l_str, 1, l_sep_length ) = sep then
            l_str := substr( l_str, l_sep_length + 1 );
        end if;
        if substr( l_str, length( l_str ) - l_sep_length + 1 ) = sep then
            l_str := substr( l_str, 1, length( l_str ) - l_sep_length );
        end if;
        loop
            pos := instr( l_str, sep );
            exit when nvl(pos,0) = 0;
            temp(i) := substr( l_str, 1, pos-1 );
            l_str := substr( l_str, pos + l_sep_length );
            i := i + 1;
        end loop;
        temp(i) := trim(l_str);
        return temp;
    exception when others then return temp;
    end;
begin
    l_old_tags := string_to_table(p_old_tags,',');
    l_new_tags := string_to_table(p_new_tags,',');
    if l_old_tags.count > 0 then --do inserts and deletes
        --build the associative arrays
        for i in 1..l_old_tags.count loop
            l_old_tags_a(l_old_tags(i)) := l_old_tags(i);
        end loop;
        for i in 1..l_new_tags.count loop
            l_new_tags_a(l_new_tags(i)) := l_new_tags(i);
        end loop;
        --do the inserts
        for i in 1..l_new_tags.count loop
            begin
                l_dummy_tag := l_old_tags_a(l_new_tags(i));
            exception when no_data_found then
                insert into TST_TAGS (tag, content_pk, content_table )
                values (trim(l_new_tags(i)), p_content_pk, p_content_table );
                l_merge_tags(l_merge_tags.count + 1) := l_new_tags(i);
            end;
        end loop;
        --do the deletes
        for i in 1..l_old_tags.count loop
            begin
                l_dummy_tag := l_new_tags_a(l_old_tags(i));
            exception when no_data_found then
                delete from TST_TAGS where content_pk = p_content_pk and tag = l_old_tags(i);
                l_merge_tags(l_merge_tags.count + 1) := l_old_tags(i);
            end;
        end loop;
    else --just do inserts
        if l_new_tags.exists(1) then
          for i in 1..l_new_tags.count loop
              insert into TST_TAGS (tag, content_pk, content_table )
              values (trim(l_new_tags(i)), p_content_pk, p_content_table );
              l_merge_tags(l_merge_tags.count + 1) := l_new_tags(i);
          end loop;
        end if;
    end if;
    for i in 1..l_merge_tags.count loop
        merge into TST_TAGS_tsum s
        using (select count(*) tag_count
                 from TST_TAGS
                where tag = l_merge_tags(i) and content_table = p_content_table ) t
        on (s.tag = l_merge_tags(i) and s.content_table = p_content_table )
        when not matched then insert (tag, content_table, tag_count)
                              values (trim(l_merge_tags(i)), p_content_table, t.tag_count)
        when matched then update set s.tag_count = t.tag_count;
        merge into TST_TAGS_sum s
        using (select sum(tag_count) tag_count
                 from TST_TAGS_tsum
                where tag = l_merge_tags(i) ) t
        on (s.tag = l_merge_tags(i) )
        when not matched then insert (tag, tag_count)
                              values (trim(l_merge_tags(i)), t.tag_count)
        when matched then update set s.tag_count = t.tag_count;
    end loop; 
end TST_TAGS_SYNC;
/

-- triggers
create or replace editionable trigger TST_CATEGORY_BIU
    before insert or update 
    on TST_CATEGORY
    for each row
declare
   function compress_int (n in integer ) return varchar2
   as
      ret       varchar2(30);
      quotient  integer;
      remainder integer;
      digit     char(1);
   begin
      ret := null; quotient := n;
      while quotient > 0
      loop
          remainder := mod(quotient, 10 + 26);
          quotient := floor(quotient  / (10 + 26));
          if remainder < 26 then
              digit := chr(ascii('A') + remainder);
          else
              digit := chr(ascii('0') + remainder - 26);
          end if;
          ret := digit || ret;
      end loop ;
      if length(ret) < 5 then ret := lpad(ret, 4, 'A'); end if ;
      return upper(ret);
   end compress_int;
begin
    if inserting then
        :new.ROW_VERSION := 1;
    elsif updating then
        :new.ROW_VERSION := NVL(:old.ROW_VERSION,0) + 1;
    end if;
    if inserting then
        :new.row_key := compress_int(TST_ROW_KEY_SEQ.nextval);
    end if;
    if inserting then
        :new.created := LOCALTIMESTAMP;
        :new.created_by := NVL(SYS_CONTEXT('APEX$SESSION','APP_USER'),user);
    end if;
    :new.updated := LOCALTIMESTAMP;
    :new.updated_by := NVL(SYS_CONTEXT('APEX$SESSION','APP_USER'),user);
end;
/

create or replace editionable trigger TST_COMPANY_BIU
    before insert or update 
    on TST_COMPANY
    for each row
declare
   function compress_int (n in integer ) return varchar2
   as
      ret       varchar2(30);
      quotient  integer;
      remainder integer;
      digit     char(1);
   begin
      ret := null; quotient := n;
      while quotient > 0
      loop
          remainder := mod(quotient, 10 + 26);
          quotient := floor(quotient  / (10 + 26));
          if remainder < 26 then
              digit := chr(ascii('A') + remainder);
          else
              digit := chr(ascii('0') + remainder - 26);
          end if;
          ret := digit || ret;
      end loop ;
      if length(ret) < 5 then ret := lpad(ret, 4, 'A'); end if ;
      return upper(ret);
   end compress_int;
begin
    if inserting then
        :new.ROW_VERSION := 1;
    elsif updating then
        :new.ROW_VERSION := NVL(:old.ROW_VERSION,0) + 1;
    end if;
    if inserting then
        :new.row_key := compress_int(TST_ROW_KEY_SEQ.nextval);
    end if;
    if inserting then
        :new.created := LOCALTIMESTAMP;
        :new.created_by := NVL(SYS_CONTEXT('APEX$SESSION','APP_USER'),user);
    end if;
    :new.updated := LOCALTIMESTAMP;
    :new.updated_by := NVL(SYS_CONTEXT('APEX$SESSION','APP_USER'),user);
end;
/

create or replace editionable trigger TST_EMPLOYEE_BIU
    before insert or update 
    on TST_EMPLOYEE
    for each row
declare
   function compress_int (n in integer ) return varchar2
   as
      ret       varchar2(30);
      quotient  integer;
      remainder integer;
      digit     char(1);
   begin
      ret := null; quotient := n;
      while quotient > 0
      loop
          remainder := mod(quotient, 10 + 26);
          quotient := floor(quotient  / (10 + 26));
          if remainder < 26 then
              digit := chr(ascii('A') + remainder);
          else
              digit := chr(ascii('0') + remainder - 26);
          end if;
          ret := digit || ret;
      end loop ;
      if length(ret) < 5 then ret := lpad(ret, 4, 'A'); end if ;
      return upper(ret);
   end compress_int;
begin
    if inserting then
        :new.ROW_VERSION := 1;
    elsif updating then
        :new.ROW_VERSION := NVL(:old.ROW_VERSION,0) + 1;
    end if;
    if inserting then
        :new.row_key := compress_int(TST_ROW_KEY_SEQ.nextval);
    end if;
    if inserting then
        :new.created := LOCALTIMESTAMP;
        :new.created_by := NVL(SYS_CONTEXT('APEX$SESSION','APP_USER'),user);
    end if;
    :new.updated := LOCALTIMESTAMP;
    :new.updated_by := NVL(SYS_CONTEXT('APEX$SESSION','APP_USER'),user);
end;
/


-- indexes
create index TST_EMPLOYEE_i1 on TST_EMPLOYEE (CATEGORY_ID);
create index TST_EMPLOYEE_i2 on TST_EMPLOYEE (COMPANY_ID);

-- history tracking
create sequence TST_HISTORY_SEQ;
create table TST_HISTORY (
    id                  number primary key,
    table_name          varchar2(128),
    column_name         varchar2(128),
    action              varchar2(1) check (action in ('I','U','D')),
    action_date         TIMESTAMP WITH LOCAL TIME ZONE,
    action_by           varchar2(255),
    data_type           varchar2(255),
    pk1                 number,
    tab_row_version     integer,
    old_vc              varchar2(4000),
    new_vc              varchar2(4000),
    old_number          number,
    new_number          number,
    old_date            date,
    new_date            date,
    old_ts              timestamp,
    new_ts              timestamp,
    old_tswtz           timestamp with time zone,
    new_tswtz           timestamp with time zone,
    old_tswltz          timestamp with local time zone,
    new_tswltz          timestamp with local time zone,
    old_clob            clob,
    new_clob            clob,
    old_blob            blob,
    new_blob            blob
)
/

create index TST_HISTORY_idx1 on TST_HISTORY (pk1);
create index TST_HISTORY_idx2 on TST_HISTORY (table_name, column_name);

create or replace view TST_HISTORY_V as
select id,
       table_name,
       column_name,
       decode(action,'U','Update','D','Delete') action,
       action_date,
       action_by,
       pk1 table_primary_key,
       tab_row_version table_row_version,
       decode(data_type,
         'NUMBER',old_number||' > '||new_number,
         'VARCHAR2',substr(old_vc,1,50)||' > '||substr(new_vc,1,50),
         'DATE',to_char(old_date,'DD-MON-YYY HH24:MI:SS')||' > '||to_char(new_date,'DD-MON-YYY HH24:MI:SS'),
         'TIMESTAMP',to_char(old_ts,'DD-MON-YYY HH24:MI:SS')||' > '||to_char(new_ts,'DD-MON-YYY HH24:MI:SS'),
         'TIMESTAMP WITH TIMEZONE',to_char(old_tswtz,'DD-MON-YYY HH24:MI:SS')||' > '||to_char(new_tswtz,'DD-MON-YYY HH24:MI:SS'),
         'TIMESTAMP WITH LOCAL TIMEZONE',to_char(old_tswltz,'DD-MON-YYY HH24:MI:SS')||' > '||to_char(new_tswltz,'DD-MON-YYY HH24:MI:SS'),
         'BLOB','length '||dbms_lob.getlength(old_blob)||' > '||' length '||dbms_lob.getlength(new_blob),
         'CLOB',dbms_lob.substr(old_vc,50,1)||' > '||dbms_lob.substr(new_vc,50,1)
         ) change
from TST_HISTORY
/

create or replace editionable trigger TST_COMPANY_AUD 
    after update or delete on TST_COMPANY
    for each row
declare
    t varchar2(128) := 'TST_COMPANY';
    u varchar2(128) := NVL(SYS_CONTEXT('APEX$SESSION','APP_USER'),user);
begin
if updating then
    if (:old.ID is null and :new.ID is not null) or 
        (:old.ID is not null and :new.ID is null) or 
        :old.ID != :new.ID then 
        insert into TST_HISTORY (
            id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_number, new_number
        ) values (
            TST_HISTORY_SEQ.nextval, t,'ID', :old.ID, :new.ROW_VERSION, 'U', SYSDATE, u, 'NUMBER', :old.ID, :new.ID);

    end if;
    if (:old.NAME is null and :new.NAME is not null) or 
        (:old.NAME is not null and :new.NAME is null) or 
        :old.NAME != :new.NAME then 
        insert into TST_HISTORY (
            id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
        ) values (
            TST_HISTORY_SEQ.nextval, t,'NAME', :old.ID, :new.ROW_VERSION, 'U', SYSDATE, u, 'VARCHAR2', :old.NAME, :new.NAME);

    end if;
elsif deleting then
    insert into TST_HISTORY (
        id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_number, new_number
    ) values (
        TST_HISTORY_SEQ.nextval, t,'ID', :old.ID, :new.ROW_VERSION, 'D', SYSDATE, u, 'NUMBER', :old.ID, :new.ID);
    insert into TST_HISTORY (
        id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
    ) values (
        TST_HISTORY_SEQ.nextval, t,'NAME', :old.ID, :new.ROW_VERSION, 'D', SYSDATE, u, 'VARCHAR2', :old.NAME, :new.NAME);

end if;
end;
/

create or replace editionable trigger TST_CATEGORY_AUD 
    after update or delete on TST_CATEGORY
    for each row
declare
    t varchar2(128) := 'TST_CATEGORY';
    u varchar2(128) := NVL(SYS_CONTEXT('APEX$SESSION','APP_USER'),user);
begin
if updating then
    if (:old.ID is null and :new.ID is not null) or 
        (:old.ID is not null and :new.ID is null) or 
        :old.ID != :new.ID then 
        insert into TST_HISTORY (
            id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_number, new_number
        ) values (
            TST_HISTORY_SEQ.nextval, t,'ID', :old.ID, :new.ROW_VERSION, 'U', SYSDATE, u, 'NUMBER', :old.ID, :new.ID);

    end if;
    if (:old.NAME is null and :new.NAME is not null) or 
        (:old.NAME is not null and :new.NAME is null) or 
        :old.NAME != :new.NAME then 
        insert into TST_HISTORY (
            id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
        ) values (
            TST_HISTORY_SEQ.nextval, t,'NAME', :old.ID, :new.ROW_VERSION, 'U', SYSDATE, u, 'VARCHAR2', :old.NAME, :new.NAME);

    end if;
elsif deleting then
    insert into TST_HISTORY (
        id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_number, new_number
    ) values (
        TST_HISTORY_SEQ.nextval, t,'ID', :old.ID, :new.ROW_VERSION, 'D', SYSDATE, u, 'NUMBER', :old.ID, :new.ID);
    insert into TST_HISTORY (
        id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
    ) values (
        TST_HISTORY_SEQ.nextval, t,'NAME', :old.ID, :new.ROW_VERSION, 'D', SYSDATE, u, 'VARCHAR2', :old.NAME, :new.NAME);

end if;
end;
/

create or replace editionable trigger TST_EMPLOYEE_AUD 
    after update or delete on TST_EMPLOYEE
    for each row
declare
    t varchar2(128) := 'TST_EMPLOYEE';
    u varchar2(128) := NVL(SYS_CONTEXT('APEX$SESSION','APP_USER'),user);
begin
if updating then
    if (:old.ID is null and :new.ID is not null) or 
        (:old.ID is not null and :new.ID is null) or 
        :old.ID != :new.ID then 
        insert into TST_HISTORY (
            id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_number, new_number
        ) values (
            TST_HISTORY_SEQ.nextval, t,'ID', :old.ID, :new.ROW_VERSION, 'U', SYSDATE, u, 'NUMBER', :old.ID, :new.ID);

    end if;
    if (:old.NAME is null and :new.NAME is not null) or 
        (:old.NAME is not null and :new.NAME is null) or 
        :old.NAME != :new.NAME then 
        insert into TST_HISTORY (
            id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
        ) values (
            TST_HISTORY_SEQ.nextval, t,'NAME', :old.ID, :new.ROW_VERSION, 'U', SYSDATE, u, 'VARCHAR2', :old.NAME, :new.NAME);

    end if;
    if (:old.COMPANY_ID is null and :new.COMPANY_ID is not null) or 
        (:old.COMPANY_ID is not null and :new.COMPANY_ID is null) or 
        :old.COMPANY_ID != :new.COMPANY_ID then 
        insert into TST_HISTORY (
            id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_number, new_number
        ) values (
            TST_HISTORY_SEQ.nextval, t,'COMPANY_ID', :old.ID, :new.ROW_VERSION, 'U', SYSDATE, u, 'NUMBER', :old.COMPANY_ID, :new.COMPANY_ID);

    end if;
    if (:old.CATEGORY_ID is null and :new.CATEGORY_ID is not null) or 
        (:old.CATEGORY_ID is not null and :new.CATEGORY_ID is null) or 
        :old.CATEGORY_ID != :new.CATEGORY_ID then 
        insert into TST_HISTORY (
            id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_number, new_number
        ) values (
            TST_HISTORY_SEQ.nextval, t,'CATEGORY_ID', :old.ID, :new.ROW_VERSION, 'U', SYSDATE, u, 'NUMBER', :old.CATEGORY_ID, :new.CATEGORY_ID);

    end if;
elsif deleting then
    insert into TST_HISTORY (
        id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_number, new_number
    ) values (
        TST_HISTORY_SEQ.nextval, t,'ID', :old.ID, :new.ROW_VERSION, 'D', SYSDATE, u, 'NUMBER', :old.ID, :new.ID);
    insert into TST_HISTORY (
        id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_vc, new_vc
    ) values (
        TST_HISTORY_SEQ.nextval, t,'NAME', :old.ID, :new.ROW_VERSION, 'D', SYSDATE, u, 'VARCHAR2', :old.NAME, :new.NAME);
    insert into TST_HISTORY (
        id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_number, new_number
    ) values (
        TST_HISTORY_SEQ.nextval, t,'COMPANY_ID', :old.ID, :new.ROW_VERSION, 'D', SYSDATE, u, 'NUMBER', :old.COMPANY_ID, :new.COMPANY_ID);
    insert into TST_HISTORY (
        id, table_name, column_name, pk1, tab_row_version, action, action_date, action_by, data_type, old_number, new_number
    ) values (
        TST_HISTORY_SEQ.nextval, t,'CATEGORY_ID', :old.ID, :new.ROW_VERSION, 'D', SYSDATE, u, 'NUMBER', :old.CATEGORY_ID, :new.CATEGORY_ID);

end if;
end;
/


-- APIs --
create or replace editionable package TST_COMPANY_API
is
 
    /* example:
        declare
            L_ROW_VERSION                   INTEGER;
            L_ROW_KEY                       VARCHAR2(30);
            L_NAME                          VARCHAR2(255);
            L_CREATED                       TIMESTAMP WITH LOCAL TIME ZONE;
            L_CREATED_BY                    VARCHAR2(255);
            L_UPDATED                       TIMESTAMP WITH LOCAL TIME ZONE;
            L_UPDATED_BY                    VARCHAR2(255);
        begin
        TST_COMPANY_API.get_row (
            P_ID                            => 1,
            P_ROW_VERSION                   => L_ROW_VERSION,
            P_ROW_KEY                       => L_ROW_KEY,
            P_NAME                          => L_NAME,
            P_CREATED                       => L_CREATED,
            P_CREATED_BY                    => L_CREATED_BY,
            P_UPDATED                       => L_UPDATED,
            P_UPDATED_BY                    => L_UPDATED_BY
            );
        end;
    */

    procedure get_row (
        P_ID                           in number,
        P_ROW_VERSION                  out INTEGER,
        P_ROW_KEY                      out VARCHAR2,
        P_NAME                         out VARCHAR2,
        P_CREATED                      out TIMESTAMP WITH LOCAL TIME ZONE,
        P_CREATED_BY                   out VARCHAR2,
        P_UPDATED                      out TIMESTAMP WITH LOCAL TIME ZONE,
        P_UPDATED_BY                   out VARCHAR2
    );
 
    /* example:
        begin
        TST_COMPANY_API.insert_row (
            P_ID                          => 1,
            P_NAME                        => 'x'
            );
        end;
    */

    procedure insert_row  (
        P_ID                           in NUMBER default null,
        P_ROW_VERSION                  in INTEGER default null,
        P_ROW_KEY                      in VARCHAR2 default null,
        P_NAME                         in VARCHAR2 default null
    );
    procedure update_row  (
        P_ID                           in NUMBER default null,
        P_NAME                         in VARCHAR2 default null
    );
    procedure delete_row (
        P_ID                           in number
    );
end TST_COMPANY_API;
/


create or replace editionable package  body TST_COMPANY_API
is
 
    procedure get_row (
        P_ID                           in number,
        P_ROW_VERSION                  out INTEGER,
        P_ROW_KEY                      out VARCHAR2,
        P_NAME                         out VARCHAR2,
        P_CREATED                      out TIMESTAMP WITH LOCAL TIME ZONE,
        P_CREATED_BY                   out VARCHAR2,
        P_UPDATED                      out TIMESTAMP WITH LOCAL TIME ZONE,
        P_UPDATED_BY                   out VARCHAR2
    )
    is
    begin
        for c1 in (select * from TST_COMPANY where id = P_ID) loop
            P_ROW_VERSION := c1.ROW_VERSION;
            P_ROW_KEY := c1.ROW_KEY;
            P_NAME := c1.NAME;
            P_CREATED := c1.CREATED;
            P_CREATED_BY := c1.CREATED_BY;
            P_UPDATED := c1.UPDATED;
            P_UPDATED_BY := c1.UPDATED_BY;
        end loop;
    end get_row;

 
    procedure insert_row  (
        P_ID                           in NUMBER default null,
        P_ROW_VERSION                  in INTEGER default null,
        P_ROW_KEY                      in VARCHAR2 default null,
        P_NAME                         in VARCHAR2 default null
    )
    is
    begin
        insert into TST_COMPANY (
            ID,
            NAME
        ) values (
            P_ID,
            P_NAME
        );
    end insert_row;

    procedure update_row  (
        P_ID                           in NUMBER default null,
        P_NAME                         in VARCHAR2 default null
    )
    is
    begin
        update  TST_COMPANY set 
            ID = P_ID,
            NAME = P_NAME
        where id = P_ID;
    end update_row;

    procedure delete_row (
        P_ID                           in number
    )
    is
    begin
        delete from TST_COMPANY where id = P_ID;
    end delete_row;

end TST_COMPANY_API;
/


create or replace editionable package TST_CATEGORY_API
is
 
    /* example:
        declare
            L_ROW_VERSION                   INTEGER;
            L_ROW_KEY                       VARCHAR2(30);
            L_NAME                          VARCHAR2(255);
            L_CREATED                       TIMESTAMP WITH LOCAL TIME ZONE;
            L_CREATED_BY                    VARCHAR2(255);
            L_UPDATED                       TIMESTAMP WITH LOCAL TIME ZONE;
            L_UPDATED_BY                    VARCHAR2(255);
        begin
        TST_CATEGORY_API.get_row (
            P_ID                            => 1,
            P_ROW_VERSION                   => L_ROW_VERSION,
            P_ROW_KEY                       => L_ROW_KEY,
            P_NAME                          => L_NAME,
            P_CREATED                       => L_CREATED,
            P_CREATED_BY                    => L_CREATED_BY,
            P_UPDATED                       => L_UPDATED,
            P_UPDATED_BY                    => L_UPDATED_BY
            );
        end;
    */

    procedure get_row (
        P_ID                           in number,
        P_ROW_VERSION                  out INTEGER,
        P_ROW_KEY                      out VARCHAR2,
        P_NAME                         out VARCHAR2,
        P_CREATED                      out TIMESTAMP WITH LOCAL TIME ZONE,
        P_CREATED_BY                   out VARCHAR2,
        P_UPDATED                      out TIMESTAMP WITH LOCAL TIME ZONE,
        P_UPDATED_BY                   out VARCHAR2
    );
 
    /* example:
        begin
        TST_CATEGORY_API.insert_row (
            P_ID                          => 1,
            P_NAME                        => 'x'
            );
        end;
    */

    procedure insert_row  (
        P_ID                           in NUMBER default null,
        P_ROW_VERSION                  in INTEGER default null,
        P_ROW_KEY                      in VARCHAR2 default null,
        P_NAME                         in VARCHAR2 default null
    );
    procedure update_row  (
        P_ID                           in NUMBER default null,
        P_NAME                         in VARCHAR2 default null
    );
    procedure delete_row (
        P_ID                           in number
    );
end TST_CATEGORY_API;
/


create or replace editionable package  body TST_CATEGORY_API
is
 
    procedure get_row (
        P_ID                           in number,
        P_ROW_VERSION                  out INTEGER,
        P_ROW_KEY                      out VARCHAR2,
        P_NAME                         out VARCHAR2,
        P_CREATED                      out TIMESTAMP WITH LOCAL TIME ZONE,
        P_CREATED_BY                   out VARCHAR2,
        P_UPDATED                      out TIMESTAMP WITH LOCAL TIME ZONE,
        P_UPDATED_BY                   out VARCHAR2
    )
    is
    begin
        for c1 in (select * from TST_CATEGORY where id = P_ID) loop
            P_ROW_VERSION := c1.ROW_VERSION;
            P_ROW_KEY := c1.ROW_KEY;
            P_NAME := c1.NAME;
            P_CREATED := c1.CREATED;
            P_CREATED_BY := c1.CREATED_BY;
            P_UPDATED := c1.UPDATED;
            P_UPDATED_BY := c1.UPDATED_BY;
        end loop;
    end get_row;

 
    procedure insert_row  (
        P_ID                           in NUMBER default null,
        P_ROW_VERSION                  in INTEGER default null,
        P_ROW_KEY                      in VARCHAR2 default null,
        P_NAME                         in VARCHAR2 default null
    )
    is
    begin
        insert into TST_CATEGORY (
            ID,
            NAME
        ) values (
            P_ID,
            P_NAME
        );
    end insert_row;

    procedure update_row  (
        P_ID                           in NUMBER default null,
        P_NAME                         in VARCHAR2 default null
    )
    is
    begin
        update  TST_CATEGORY set 
            ID = P_ID,
            NAME = P_NAME
        where id = P_ID;
    end update_row;

    procedure delete_row (
        P_ID                           in number
    )
    is
    begin
        delete from TST_CATEGORY where id = P_ID;
    end delete_row;

end TST_CATEGORY_API;
/


create or replace editionable package TST_EMPLOYEE_API
is
 
    /* example:
        declare
            L_ROW_VERSION                   INTEGER;
            L_ROW_KEY                       VARCHAR2(30);
            L_NAME                          VARCHAR2(255);
            L_COMPANY_ID                    NUMBER;
            L_CATEGORY_ID                   NUMBER;
            L_CREATED                       TIMESTAMP WITH LOCAL TIME ZONE;
            L_CREATED_BY                    VARCHAR2(255);
            L_UPDATED                       TIMESTAMP WITH LOCAL TIME ZONE;
            L_UPDATED_BY                    VARCHAR2(255);
        begin
        TST_EMPLOYEE_API.get_row (
            P_ID                            => 1,
            P_ROW_VERSION                   => L_ROW_VERSION,
            P_ROW_KEY                       => L_ROW_KEY,
            P_NAME                          => L_NAME,
            P_COMPANY_ID                    => L_COMPANY_ID,
            P_CATEGORY_ID                   => L_CATEGORY_ID,
            P_CREATED                       => L_CREATED,
            P_CREATED_BY                    => L_CREATED_BY,
            P_UPDATED                       => L_UPDATED,
            P_UPDATED_BY                    => L_UPDATED_BY
            );
        end;
    */

    procedure get_row (
        P_ID                           in number,
        P_ROW_VERSION                  out INTEGER,
        P_ROW_KEY                      out VARCHAR2,
        P_NAME                         out VARCHAR2,
        P_COMPANY_ID                   out NUMBER,
        P_CATEGORY_ID                  out NUMBER,
        P_CREATED                      out TIMESTAMP WITH LOCAL TIME ZONE,
        P_CREATED_BY                   out VARCHAR2,
        P_UPDATED                      out TIMESTAMP WITH LOCAL TIME ZONE,
        P_UPDATED_BY                   out VARCHAR2
    );
 
    /* example:
        begin
        TST_EMPLOYEE_API.insert_row (
            P_ID                          => 1,
            P_NAME                        => 'x',
            P_COMPANY_ID                  => 1,
            P_CATEGORY_ID                 => 1
            );
        end;
    */

    procedure insert_row  (
        P_ID                           in NUMBER default null,
        P_ROW_VERSION                  in INTEGER default null,
        P_ROW_KEY                      in VARCHAR2 default null,
        P_NAME                         in VARCHAR2 default null,
        P_COMPANY_ID                   in NUMBER default null,
        P_CATEGORY_ID                  in NUMBER default null
    );
    procedure update_row  (
        P_ID                           in NUMBER default null,
        P_NAME                         in VARCHAR2 default null,
        P_COMPANY_ID                   in NUMBER default null,
        P_CATEGORY_ID                  in NUMBER default null
    );
    procedure delete_row (
        P_ID                           in number
    );
end TST_EMPLOYEE_API;
/


create or replace editionable package  body TST_EMPLOYEE_API
is
 
    procedure get_row (
        P_ID                           in number,
        P_ROW_VERSION                  out INTEGER,
        P_ROW_KEY                      out VARCHAR2,
        P_NAME                         out VARCHAR2,
        P_COMPANY_ID                   out NUMBER,
        P_CATEGORY_ID                  out NUMBER,
        P_CREATED                      out TIMESTAMP WITH LOCAL TIME ZONE,
        P_CREATED_BY                   out VARCHAR2,
        P_UPDATED                      out TIMESTAMP WITH LOCAL TIME ZONE,
        P_UPDATED_BY                   out VARCHAR2
    )
    is
    begin
        for c1 in (select * from TST_EMPLOYEE where id = P_ID) loop
            P_ROW_VERSION := c1.ROW_VERSION;
            P_ROW_KEY := c1.ROW_KEY;
            P_NAME := c1.NAME;
            P_COMPANY_ID := c1.COMPANY_ID;
            P_CATEGORY_ID := c1.CATEGORY_ID;
            P_CREATED := c1.CREATED;
            P_CREATED_BY := c1.CREATED_BY;
            P_UPDATED := c1.UPDATED;
            P_UPDATED_BY := c1.UPDATED_BY;
        end loop;
    end get_row;

 
    procedure insert_row  (
        P_ID                           in NUMBER default null,
        P_ROW_VERSION                  in INTEGER default null,
        P_ROW_KEY                      in VARCHAR2 default null,
        P_NAME                         in VARCHAR2 default null,
        P_COMPANY_ID                   in NUMBER default null,
        P_CATEGORY_ID                  in NUMBER default null
    )
    is
    begin
        insert into TST_EMPLOYEE (
            ID,
            NAME,
            COMPANY_ID,
            CATEGORY_ID
        ) values (
            P_ID,
            P_NAME,
            P_COMPANY_ID,
            P_CATEGORY_ID
        );
    end insert_row;

    procedure update_row  (
        P_ID                           in NUMBER default null,
        P_NAME                         in VARCHAR2 default null,
        P_COMPANY_ID                   in NUMBER default null,
        P_CATEGORY_ID                  in NUMBER default null
    )
    is
    begin
        update  TST_EMPLOYEE set 
            ID = P_ID,
            NAME = P_NAME,
            COMPANY_ID = P_COMPANY_ID,
            CATEGORY_ID = P_CATEGORY_ID
        where id = P_ID;
    end update_row;

    procedure delete_row (
        P_ID                           in number
    )
    is
    begin
        delete from TST_EMPLOYEE where id = P_ID;
    end delete_row;

end TST_EMPLOYEE_API;
/



-- load data
 
-- Generated by Quick SQL Monday May 08, 2017  17:08:35
 
/*
company
 name
category
 name
employee
 name
 company_id
 category_id

# settings = { prefix: "TST_", date: "TIMESTAMP WITH LOCAL TIME ZONE", API: true, auditCols: true, rowKey: true, rowVersion: true, drop: true, hist: true, editionable: true, APEX: true, uncomment: false, tags: true }
*/
